use std::sync::{Arc, RwLock, Weak};

use pluginop_common::quic::{ConnectionField, RecoveryField};
use wasmer::{Exports, Function, FunctionEnv, FunctionEnvMut, Imports, Store, WasmPtr};

use crate::{plugin::Env, PluginizableConnection};

/// A trait that needs to be implemented by the host implementation to provide
/// plugins information from the host.
pub trait ConnectionToPlugin<'a, P: PluginizableConnection>: Send {
    /// Gets the related `ConnectionField` and writes it as a serialized value in `w`.
    /// It is up to the plugin to correctly handle the value and perform the serialization.
    fn get_connection(&self, w: &mut [u8], field: ConnectionField) -> bincode::Result<()>;
    /// Sets the related `ConnectionField` to the provided value, that was serialized with content
    /// `value`. It is this function responsibility to correctly convert the
    /// input to the right type.
    fn set_connection(&mut self, field: ConnectionField, value: &[u8]);
    /// Gets the related `RecoveryField` and writes it as a serialized value in `w`. It is up to the
    /// plugin to correctly handle the value and perform the serialization.
    fn get_recovery(&self, w: &mut [u8], field: RecoveryField) -> bincode::Result<()>;
    /// Sets the related `RecoveryField` to the provided value, that was serialized with content
    /// `value`. It is this function responsibility to correctly convert the
    /// input to the right type.
    fn set_recovery(&mut self, field: RecoveryField, value: &[u8]);
    /// Sets the pluginizable connection.
    fn set_pluginizable_conn(&mut self, pc: &Arc<RwLock<P>>);
    /// Gets the pluginizable connection.
    fn get_pluginizable_conn(&self) -> Option<&Weak<RwLock<P>>>;
}

// -------------------------------- API FUNCTIONS ----------------------------------

/// Stores a value generated by a running plugin as one of its outputs.
///
/// Function intended to be part of the Plugin API.
fn save_output_from_plugin<P: PluginizableConnection>(
    mut env: FunctionEnvMut<Env<P>>,
    ptr: WasmPtr<u8>,
    len: u32,
) {
    let instance = env.data().get_instance();
    let instance = instance.as_ref();
    let memory = instance.exports.get_memory("memory").expect("no memory");
    let view = memory.view(&env);
    let output_cells = ptr.slice(&view, len).unwrap();
    let output_serialized = output_cells.read_to_vec().unwrap();
    env.data_mut().outputs.push(output_serialized);
}

/// Stores a value in an opaque, persistent store maintained by the host implementation. The stored
/// value is identified by its tag.
///
/// Function intended to be part of the Plugin API.
fn store_opaque_from_plugin<P: PluginizableConnection>(
    mut env: FunctionEnvMut<Env<P>>,
    tag: u64,
    val: u32,
) {
    let env_data = env.data_mut();
    env_data.opaque_values.insert(tag, val);
}

/// Gets the value associated to `tag` from the opaque, persistant store maintained by the host
/// implementation. If the `tag` is not present in the store, returns `u32::MAX`.
///
/// Function intended to be part of the Plugin API.
fn get_opaque_from_plugin<P: PluginizableConnection>(
    mut env: FunctionEnvMut<Env<P>>,
    tag: u64,
) -> u64 {
    let env_data = env.data_mut();
    match env_data.opaque_values.get(&tag) {
        Some(v) => u64::from(*v),
        None => {
            // We need a well-known return value, so let's put MAX_INT
            u64::MAX
        }
    }
}

/// Removes the value associated to `tag` for the opaque, persistant store maintained by the host
/// implementation.
fn remove_opaque_from_plugin<P: PluginizableConnection>(
    mut env: FunctionEnvMut<Env<P>>,
    tag: u64,
) -> u64 {
    let env_data = env.data_mut();
    match env_data.opaque_values.remove(&tag) {
        Some(v) => u64::from(v),
        None => {
            // We need a well-known return value, so let's put MAX_INT
            u64::MAX
        }
    }
}

/// Gets a serialized input.
///
/// Function intended to be part of the Plugin API.
///
/// Returns `0` if the operation succeeded. Otherwise, returns a negative value.
fn get_input_from_plugin<P: PluginizableConnection>(
    env: FunctionEnvMut<Env<P>>,
    index: u32,
    mem_ptr: WasmPtr<u8>,
    mem_len: u32,
) -> i32 {
    let instance = env.data().get_instance();
    let instance = instance.as_ref();
    let memory = match instance.exports.get_memory("memory") {
        Ok(m) => m,
        Err(_) => return -1,
    };
    let view = memory.view(&env);
    let input = match env.data().inputs.get(index as usize) {
        Some(i) => i,
        None => return -2,
    };
    // Sanity check to avoid memory overwrite.
    match bincode::serialized_size(input) {
        Ok(l) if l > mem_len.into() => return -3,
        Err(_) => return -4,
        _ => {}
    };
    // SAFETY: Given that plugins are single-threaded per-connection, this does
    // not introduce any UB.
    let memory_slice = unsafe { view.data_unchecked_mut() };
    match bincode::serialize_into(&mut memory_slice[mem_ptr.offset() as usize..], input) {
        Ok(()) => 0,
        Err(_) => -5,
    }
}

/// Gets the serialized inputs.
///
/// Function intended to be part of the Plugin API.
///
/// Returns `0` if the operation succeeded. Otherwise, returns a negative value.
fn get_inputs_from_plugin<P: PluginizableConnection>(
    env: FunctionEnvMut<Env<P>>,
    mem_ptr: WasmPtr<u8>,
    mem_len: u32,
) -> i32 {
    let instance = env.data().get_instance();
    let instance = instance.as_ref();
    let memory = match instance.exports.get_memory("memory") {
        Ok(m) => m,
        Err(_) => return -1,
    };
    let view = memory.view(&env);
    // Sanity check to avoid memory overwrite.
    match bincode::serialized_size(&*env.data().inputs) {
        Ok(l) if l > mem_len.into() => return -2,
        Err(_) => return -3,
        _ => {}
    };
    // SAFETY: Given that plugins are single-threaded per-connection, this does
    // not introduce any UB.
    let memory_slice = unsafe { view.data_unchecked_mut() };
    match bincode::serialize_into(
        &mut memory_slice[mem_ptr.offset() as usize..],
        &*env.data().inputs,
    ) {
        Ok(()) => 0,
        Err(_) => -4,
    }
}

/// Prints the content of the plugin memory located at the address `ptr` as a `str` having a length
/// of `len`.
///
/// Code from https://github.com/wasmerio/wasmer-rust-example/blob/master/examples/string.rs
///
/// Function intended to be part of the Plugin API.
pub fn print_from_plugin<P: PluginizableConnection>(
    env: FunctionEnvMut<Env<P>>,
    ptr: WasmPtr<u8>,
    len: u32,
) {
    let instance = env.data().get_instance();
    let instance = instance.as_ref();
    let memory = match instance.exports.get_memory("memory") {
        Ok(m) => m,
        Err(_) => return,
    };
    let view = memory.view(&env);

    // Uses the WasmPtr wrapper to simplify the operation to get ptr memory.
    if let Ok(s) = ptr.read_utf8_string(&view, len) {
        // Print it!
        println!("{s}");
    }
}

/// Gets the imports that are common to any implementation.
///
/// The host implementation still needs to privide the following functions:
///    - buffer_get_bytes_from_plugin
///    - buffer_put_bytes_from_plugin
pub fn get_imports_with<P: PluginizableConnection>(
    mut exports: Exports,
    store: &mut Store,
    env: &FunctionEnv<Env<P>>,
) -> Imports {
    // Place here all the functions that are common to any host.
    exports.insert(
        "save_output_from_plugin",
        Function::new_typed_with_env(store, env, save_output_from_plugin),
    );
    exports.insert(
        "store_opaque_from_plugin",
        Function::new_typed_with_env(store, env, store_opaque_from_plugin),
    );
    exports.insert(
        "get_opaque_from_plugin",
        Function::new_typed_with_env(store, env, get_opaque_from_plugin),
    );
    exports.insert(
        "remove_opaque_from_plugin",
        Function::new_typed_with_env(store, env, remove_opaque_from_plugin),
    );
    exports.insert(
        "get_input_from_plugin",
        Function::new_typed_with_env(store, env, get_input_from_plugin),
    );
    exports.insert(
        "get_inputs_from_plugin",
        Function::new_typed_with_env(store, env, get_inputs_from_plugin),
    );
    exports.insert(
        "print_from_plugin",
        Function::new_typed_with_env(store, env, print_from_plugin),
    );

    let mut imports = Imports::new();
    imports.register_namespace("env", exports);
    imports
}
